<div class="slide-content">
    <div class="slide-header">
        <span class="slide-chapter">01 â€¢ Bloom Filters</span>
        <h2>ðŸ“Š Calcule Practice</h2>
    </div>
    <div class="slide-body code-slide">
        <div class="code-block">
            <div class="code-header">
                <span class="code-lang">Python</span>
                <button class="run-btn" onclick="runPythonCode('bloomMath')">
                    <span class="play-icon">â–¶</span> RuleazÄƒ
                </button>
            </div>
            <pre class="language-python"><code class="language-python" id="bloomMath">import math

def probabilitate_fp(m, n, k):
    return (1 - math.exp(-k * n / m)) ** k

def k_optim(m, n):
    return (m / n) * math.log(2)

def m_optim(n, p):
    return -n * math.log(p) / (math.log(2) ** 2)

# Scenariul: 1 milion de elemente, 1% false positive
n = 1_000_000
p_target = 0.01

m_needed = m_optim(n, p_target)
k_needed = k_optim(m_needed, n)

print(f"Pentru {n:,} elemente cu {p_target*100}% FP:")
print(f"  Memorie necesarÄƒ: {m_needed/8/1024/1024:.2f} MB")
print(f"  FuncÈ›ii hash optime: {round(k_needed)}")

# ComparaÈ›ie cu HashSet (~40 bytes/element)
hashset_size = n * 40 / 1024 / 1024
print(f"\nComparaÈ›ie:")
print(f"  HashSet: ~{hashset_size:.0f} MB")
print(f"  Bloom:   ~{m_needed/8/1024/1024:.2f} MB")
print(f"  Economie: {(1-m_needed/8/1024/1024/hashset_size)*100:.0f}%")</code></pre>
            <div class="code-output" id="output-bloomMath">
                <span class="output-placeholder">ApasÄƒ "RuleazÄƒ" pentru a vedea rezultatul...</span>
            </div>
        </div>
    </div>
</div>

