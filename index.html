<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structuri de Date Probabilistice | SDA PolitehnicÄƒ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Playfair+Display:wght@600;700;800&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
    <!-- Cover Section -->
    <section class="cover slide" id="cover" data-slide="0">
        <div class="cover-bg">
            <div class="grid-overlay"></div>
            <div class="floating-bits">
                <span class="bit">0</span><span class="bit">1</span><span class="bit">1</span>
                <span class="bit">0</span><span class="bit">1</span><span class="bit">0</span>
                <span class="bit">1</span><span class="bit">0</span><span class="bit">1</span>
                <span class="bit">1</span><span class="bit">0</span><span class="bit">0</span>
            </div>
        </div>
        <div class="cover-content">
            <div class="institution">
                <span class="diamond">â—†</span>
                <span>Universitatea Politehnica BucureÈ™ti</span>
                <span class="diamond">â—†</span>
            </div>
            <h1 class="cover-title">
                <span class="title-line">Structuri de Date</span>
                <span class="title-line accent">Probabilistice</span>
            </h1>
            <p class="cover-subtitle">Curs de Structuri de Date È™i Algoritmi</p>
            <div class="cover-topics">
                <div class="topic-pill">
                    <span class="topic-icon">â—</span>
                    <span>Bloom Filters</span>
                </div>
                <div class="topic-pill">
                    <span class="topic-icon">â—</span>
                    <span>HyperLogLog</span>
                </div>
            </div>
            <a href="#introduction" class="start-btn">
                <span>Ãncepe Cursul</span>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M19 12l-7 7-7-7"/>
                </svg>
            </a>
        </div>
        <div class="scroll-indicator">
            <div class="mouse">
                <div class="wheel"></div>
            </div>
        </div>
    </section>

    <!-- Navigation -->
    <nav class="main-nav" id="mainNav">
        <div class="nav-brand">SDA <span class="accent">Probabilistic</span></div>
        <ul class="nav-links">
            <li><a href="#introduction">Introducere</a></li>
            <li><a href="#bloom-filters">Bloom Filters</a></li>
            <li><a href="#hyperloglog">HyperLogLog</a></li>
        </ul>
        <div class="pyodide-status" id="pyodideStatus">
            <span class="status-dot loading"></span>
            <span class="status-text">Se Ã®ncarcÄƒ Python...</span>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="content">
        
        <!-- Introduction Section -->
        <section class="section slide" id="introduction" data-slide="1" data-title="Introducere">
            <div class="section-header">
                <span class="section-number">00</span>
                <h2>Introducere</h2>
            </div>
            <div class="section-content">
                <div class="intro-card">
                    <h3>Ce sunt Structurile de Date Probabilistice?</h3>
                    <p>
                        Structurile de date probabilistice sunt structuri care folosesc <strong>randomizarea</strong> 
                        pentru a oferi rÄƒspunsuri aproximative, dar cu garanÈ›ii matematice privind acurateÈ›ea. 
                        Ele sacrificÄƒ precizia perfectÄƒ Ã®n schimbul unor avantaje semnificative:
                    </p>
                    <ul class="feature-list">
                        <li>
                            <span class="feature-icon">âš¡</span>
                            <div>
                                <strong>EficienÈ›Äƒ spaÈ›ialÄƒ</strong>
                                <p>Folosesc mult mai puÈ›inÄƒ memorie decÃ¢t structurile deterministe</p>
                            </div>
                        </li>
                        <li>
                            <span class="feature-icon">ğŸš€</span>
                            <div>
                                <strong>VitezÄƒ</strong>
                                <p>OperaÈ›iile sunt de obicei O(1) sau O(k) unde k este mic</p>
                            </div>
                        </li>
                        <li>
                            <span class="feature-icon">ğŸ“Š</span>
                            <div>
                                <strong>Scalabilitate</strong>
                                <p>Perfecte pentru Big Data È™i streaming</p>
                            </div>
                        </li>
                    </ul>
                </div>
                
                <div class="comparison-table">
                    <h4>ComparaÈ›ie: Deterministic vs Probabilistic</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>CaracteristicÄƒ</th>
                                <th>HashSet (Deterministic)</th>
                                <th>Bloom Filter (Probabilistic)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Memorie pentru 1M elemente</td>
                                <td class="bad">~40 MB</td>
                                <td class="good">~1.2 MB</td>
                            </tr>
                            <tr>
                                <td>False Positives</td>
                                <td class="good">0%</td>
                                <td class="neutral">~1% (configurabil)</td>
                            </tr>
                            <tr>
                                <td>False Negatives</td>
                                <td class="good">0%</td>
                                <td class="good">0%</td>
                            </tr>
                            <tr>
                                <td>È˜tergere element</td>
                                <td class="good">Da</td>
                                <td class="bad">Nu (standard)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Bloom Filters Section -->
        <section class="section" id="bloom-filters">
            <div class="section-header">
                <span class="section-number">01</span>
                <h2>Bloom Filters</h2>
            </div>
            <div class="section-content">
                
                <div class="theory-block">
                    <h3>Ce este un Bloom Filter?</h3>
                    <p>
                        Un <strong>Bloom Filter</strong> este o structurÄƒ de date probabilisticÄƒ, inventatÄƒ de 
                        Burton Howard Bloom Ã®n 1970, care permite testarea eficientÄƒ a apartenenÈ›ei unui element 
                        la o mulÈ›ime.
                    </p>
                    
                    <div class="key-concept">
                        <div class="concept-header">
                            <span class="concept-icon">ğŸ’¡</span>
                            <h4>Principiul Fundamental</h4>
                        </div>
                        <p>
                            Un Bloom Filter poate rÄƒspunde la Ã®ntrebarea <em>"Este elementul X Ã®n mulÈ›ime?"</em> cu:
                        </p>
                        <ul>
                            <li><strong>"Probabil DA"</strong> - elementul ar putea fi Ã®n mulÈ›ime (cu o micÄƒ probabilitate de eroare)</li>
                            <li><strong>"Sigur NU"</strong> - elementul nu este Ã®n mulÈ›ime (100% sigur)</li>
                        </ul>
                    </div>
                </div>

                <div class="theory-block">
                    <h3>Cum funcÈ›ioneazÄƒ?</h3>
                    <div class="steps-container">
                        <div class="step">
                            <div class="step-number">1</div>
                            <div class="step-content">
                                <h4>Structura</h4>
                                <p>Un vector de <code>m</code> biÈ›i, iniÈ›ial toÈ›i setaÈ›i pe 0, È™i <code>k</code> funcÈ›ii hash independente.</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">2</div>
                            <div class="step-content">
                                <h4>Inserare</h4>
                                <p>Pentru fiecare element, se calculeazÄƒ <code>k</code> hash-uri È™i se seteazÄƒ biÈ›ii corespunzÄƒtori pe 1.</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">3</div>
                            <div class="step-content">
                                <h4>CÄƒutare</h4>
                                <p>Se verificÄƒ dacÄƒ toÈ›i cei <code>k</code> biÈ›i sunt 1. DacÄƒ cel puÈ›in unul e 0, elementul sigur nu existÄƒ.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interactive Bloom Filter Visualization -->
                <div class="interactive-demo">
                    <h3>ğŸ® Demo Interactiv: Bloom Filter</h3>
                    <div class="demo-controls">
                        <input type="text" id="bloomInput" placeholder="Introdu un cuvÃ¢nt..." class="demo-input">
                        <button onclick="addToBloom()" class="demo-btn primary">AdaugÄƒ</button>
                        <button onclick="checkBloom()" class="demo-btn secondary">VerificÄƒ</button>
                        <button onclick="resetBloom()" class="demo-btn danger">Reset</button>
                    </div>
                    <div class="bloom-visualization">
                        <div class="bit-array" id="bloomBitArray">
                            <!-- Generated by JS -->
                        </div>
                        <div class="hash-indicators" id="hashIndicators"></div>
                    </div>
                    <div class="demo-output" id="bloomOutput">
                        <p>AdaugÄƒ cuvinte pentru a vedea cum funcÈ›ioneazÄƒ Bloom Filter-ul.</p>
                    </div>
                    <div class="added-elements">
                        <strong>Elemente adÄƒugate:</strong>
                        <span id="addedList">Niciun element Ã®ncÄƒ</span>
                    </div>
                </div>

                <!-- Python Code Section -->
                <div class="code-section">
                    <h3>ğŸ“ Implementare Python</h3>
                    <p>RuleazÄƒ codul de mai jos pentru a vedea Bloom Filter-ul Ã®n acÈ›iune:</p>
                    
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Python</span>
                            <button class="run-btn" onclick="runPythonCode('bloomCode1')">
                                <span class="play-icon">â–¶</span> RuleazÄƒ
                            </button>
                        </div>
                        <pre><code id="bloomCode1">import hashlib

class BloomFilter:
    def __init__(self, size=100, num_hashes=3):
        """
        IniÈ›ializeazÄƒ un Bloom Filter.
        
        Args:
            size: NumÄƒrul de biÈ›i Ã®n vector
            num_hashes: NumÄƒrul de funcÈ›ii hash
        """
        self.size = size
        self.num_hashes = num_hashes
        self.bit_array = [0] * size
        self.elements_count = 0
    
    def _hashes(self, item):
        """GenereazÄƒ k hash-uri pentru un element."""
        hashes = []
        for i in range(self.num_hashes):
            # Folosim SHA-256 cu seed diferit pentru fiecare hash
            h = hashlib.sha256(f"{item}{i}".encode()).hexdigest()
            hashes.append(int(h, 16) % self.size)
        return hashes
    
    def add(self, item):
        """AdaugÄƒ un element Ã®n Bloom Filter."""
        for pos in self._hashes(item):
            self.bit_array[pos] = 1
        self.elements_count += 1
        print(f"âœ“ AdÄƒugat '{item}' la poziÈ›iile: {self._hashes(item)}")
    
    def contains(self, item):
        """VerificÄƒ dacÄƒ un element ar putea fi Ã®n filter."""
        positions = self._hashes(item)
        result = all(self.bit_array[pos] == 1 for pos in positions)
        return result, positions

# DemonstraÈ›ie
print("=" * 50)
print("BLOOM FILTER - DemonstraÈ›ie")
print("=" * 50)

bf = BloomFilter(size=20, num_hashes=3)

# AdÄƒugÄƒm cÃ¢teva elemente
elemente = ["pisicÄƒ", "cÃ¢ine", "papagal"]
print("\nğŸ“¥ AdÄƒugÄƒm elemente:")
for elem in elemente:
    bf.add(elem)

# VizualizÄƒm vectorul de biÈ›i
print(f"\nğŸ“Š Vector de biÈ›i: {bf.bit_array}")
print(f"   BiÈ›i setaÈ›i: {sum(bf.bit_array)} din {bf.size}")

# TestÄƒm cÄƒutarea
print("\nğŸ” TestÄƒm cÄƒutarea:")
test_items = ["pisicÄƒ", "cÃ¢ine", "elefant", "leu"]
for item in test_items:
    found, positions = bf.contains(item)
    status = "PROBABIL DA âœ“" if found else "SIGUR NU âœ—"
    print(f"   '{item}': {status} (pozÈ›ii verificate: {positions})")</code></pre>
                        <div class="code-output" id="output-bloomCode1">
                            <span class="output-placeholder">ApasÄƒ "RuleazÄƒ" pentru a vedea rezultatul...</span>
                        </div>
                    </div>
                </div>

                <!-- Math Section -->
                <div class="math-section">
                    <h3>ğŸ“ Analiza MatematicÄƒ</h3>
                    
                    <div class="formula-card">
                        <h4>Probabilitatea de False Positive</h4>
                        <div class="formula">
                            <p>DupÄƒ inserarea a <code>n</code> elemente Ã®ntr-un Bloom Filter cu <code>m</code> biÈ›i È™i <code>k</code> funcÈ›ii hash:</p>
                            <div class="math-formula">
                                P(false positive) â‰ˆ (1 - e<sup>-kn/m</sup>)<sup>k</sup>
                            </div>
                        </div>
                    </div>

                    <div class="formula-card">
                        <h4>NumÄƒrul Optim de FuncÈ›ii Hash</h4>
                        <div class="formula">
                            <div class="math-formula">
                                k<sub>optim</sub> = (m/n) Ã— ln(2) â‰ˆ 0.693 Ã— (m/n)
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Python</span>
                            <button class="run-btn" onclick="runPythonCode('bloomMath')">
                                <span class="play-icon">â–¶</span> RuleazÄƒ
                            </button>
                        </div>
                        <pre><code id="bloomMath">import math

def calculeaza_probabilitate_fp(m, n, k):
    """
    CalculeazÄƒ probabilitatea de false positive.
    
    Args:
        m: NumÄƒrul de biÈ›i
        n: NumÄƒrul de elemente
        k: NumÄƒrul de funcÈ›ii hash
    """
    return (1 - math.exp(-k * n / m)) ** k

def k_optim(m, n):
    """CalculeazÄƒ numÄƒrul optim de funcÈ›ii hash."""
    return (m / n) * math.log(2)

def m_optim(n, p):
    """
    CalculeazÄƒ dimensiunea optimÄƒ pentru o probabilitate È›intÄƒ.
    
    Args:
        n: NumÄƒrul estimat de elemente
        p: Probabilitatea de false positive doritÄƒ
    """
    return -n * math.log(p) / (math.log(2) ** 2)

print("=" * 60)
print("ANALIZA MATEMATICÄ‚ - Bloom Filter")
print("=" * 60)

# Scenariul 1: Dimensiune fixÄƒ
print("\nğŸ“Š Scenariul 1: m=1000 biÈ›i, n=100 elemente")
m, n = 1000, 100
k_opt = k_optim(m, n)
print(f"   k optim = {k_opt:.2f} (rotunjit: {round(k_opt)})")

for k in [1, 3, 7, 10, 15]:
    p = calculeaza_probabilitate_fp(m, n, k)
    print(f"   k={k:2d}: P(false positive) = {p*100:.4f}%")

# Scenariul 2: Probabilitate È›intÄƒ
print("\nğŸ“Š Scenariul 2: n=1,000,000 elemente, p=1% È›intÄƒ")
n = 1_000_000
p_target = 0.01
m_needed = m_optim(n, p_target)
k_needed = k_optim(m_needed, n)

print(f"   Memorie necesarÄƒ: {m_needed/8/1024/1024:.2f} MB")
print(f"   k optim: {k_needed:.2f} (rotunjit: {round(k_needed)})")

# ComparaÈ›ie cu HashSet
print("\nğŸ“Š ComparaÈ›ie cu HashSet (presupunÃ¢nd 40 bytes/element):")
hashset_size = n * 40 / 1024 / 1024
print(f"   HashSet:      ~{hashset_size:.2f} MB")
print(f"   Bloom Filter: ~{m_needed/8/1024/1024:.2f} MB")
print(f"   Economie:     ~{hashset_size - m_needed/8/1024/1024:.2f} MB ({(1-m_needed/8/1024/1024/hashset_size)*100:.1f}%)")</code></pre>
                        <div class="code-output" id="output-bloomMath">
                            <span class="output-placeholder">ApasÄƒ "RuleazÄƒ" pentru a vedea rezultatul...</span>
                        </div>
                    </div>
                </div>

                <!-- Applications -->
                <div class="applications-section">
                    <h3>ğŸŒ AplicaÈ›ii Ã®n Lumea RealÄƒ</h3>
                    <div class="app-grid">
                        <div class="app-card">
                            <div class="app-icon">ğŸŒ</div>
                            <h4>Google Chrome</h4>
                            <p>VerificÄƒ URL-uri maliÈ›ioase folosind un Bloom Filter local Ã®nainte de a contacta serverele.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸ’¾</div>
                            <h4>Baze de Date</h4>
                            <p>Cassandra, HBase folosesc Bloom Filters pentru a evita citiri inutile de pe disc.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸ“§</div>
                            <h4>Filtre de Spam</h4>
                            <p>VerificÄƒ rapid dacÄƒ un email provine de la un expeditor cunoscut.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸ”—</div>
                            <h4>Blockchain</h4>
                            <p>Bitcoin foloseÈ™te Bloom Filters pentru SPV (Simplified Payment Verification).</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- HyperLogLog Section -->
        <section class="section" id="hyperloglog">
            <div class="section-header">
                <span class="section-number">02</span>
                <h2>HyperLogLog</h2>
            </div>
            <div class="section-content">
                
                <div class="theory-block">
                    <h3>Ce este HyperLogLog?</h3>
                    <p>
                        <strong>HyperLogLog</strong> (HLL) este un algoritm probabilistic pentru estimarea 
                        cardinalitÄƒÈ›ii (numÄƒrului de elemente distincte) Ã®ntr-o mulÈ›ime, dezvoltat de 
                        Flajolet et al. Ã®n 2007.
                    </p>
                    
                    <div class="key-concept highlight-orange">
                        <div class="concept-header">
                            <span class="concept-icon">ğŸ¯</span>
                            <h4>Problema pe care o rezolvÄƒ</h4>
                        </div>
                        <p>
                            ImagineazÄƒ-È›i cÄƒ trebuie sÄƒ numeri cÃ¢È›i utilizatori unici viziteazÄƒ un website 
                            cu miliarde de vizite pe zi. PÄƒstrarea tuturor ID-urilor ar necesita terabytes de memorie!
                        </p>
                        <p>
                            <strong>HyperLogLog poate estima acest numÄƒr folosind doar ~12KB de memorie</strong>, 
                            cu o eroare de doar ~0.8%.
                        </p>
                    </div>
                </div>

                <div class="theory-block">
                    <h3>IntuiÈ›ia din spatele algoritmului</h3>
                    <div class="intuition-box">
                        <h4>ğŸ² Experimentul cu moneda</h4>
                        <p>ImagineazÄƒ-È›i cÄƒ arunci o monedÄƒ È™i numeri cÃ¢te aruncÄƒri consecutive de "cap" obÈ›ii:</p>
                        <ul>
                            <li>1 "cap" consecutiv â†’ foarte comun (probabilitate 50%)</li>
                            <li>2 "cap" consecutive â†’ destul de comun (probabilitate 25%)</li>
                            <li>10 "cap" consecutive â†’ foarte rar (probabilitate 0.1%)</li>
                            <li>20 "cap" consecutive â†’ extrem de rar (probabilitate ~0.0001%)</li>
                        </ul>
                        <p>
                            <strong>Ideea cheie:</strong> DacÄƒ am observat k zerouri consecutive la Ã®nceputul 
                            unui hash, probabil am vÄƒzut aproximativ 2<sup>k</sup> elemente distincte!
                        </p>
                    </div>
                </div>

                <div class="theory-block">
                    <h3>Cum funcÈ›ioneazÄƒ HyperLogLog?</h3>
                    <div class="steps-container">
                        <div class="step">
                            <div class="step-number">1</div>
                            <div class="step-content">
                                <h4>Hash</h4>
                                <p>Fiecare element este hash-uit Ã®ntr-un numÄƒr binar uniform distribuit.</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">2</div>
                            <div class="step-content">
                                <h4>ÃmpÄƒrÈ›ire Ã®n registre</h4>
                                <p>Primii <code>p</code> biÈ›i determinÄƒ Ã®n care din cele 2<sup>p</sup> registre se Ã®ncadreazÄƒ elementul.</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">3</div>
                            <div class="step-content">
                                <h4>NumÄƒrare zerouri</h4>
                                <p>Se numÄƒrÄƒ cÃ¢te zerouri consecutive apar la Ã®nceputul biÈ›ilor rÄƒmaÈ™i (leading zeros).</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">4</div>
                            <div class="step-content">
                                <h4>Actualizare registru</h4>
                                <p>Se pÄƒstreazÄƒ maximul Ã®ntre valoarea curentÄƒ È™i numÄƒrul de zerouri + 1.</p>
                            </div>
                        </div>
                        <div class="step">
                            <div class="step-number">5</div>
                            <div class="step-content">
                                <h4>Estimare</h4>
                                <p>Cardinalitatea se estimeazÄƒ folosind media armonicÄƒ a valorilor din registre.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interactive HLL Demo -->
                <div class="interactive-demo hll-demo">
                    <h3>ğŸ® Demo Interactiv: HyperLogLog</h3>
                    <div class="demo-controls">
                        <button onclick="addRandomElements(10)" class="demo-btn primary">+10 Elemente</button>
                        <button onclick="addRandomElements(100)" class="demo-btn primary">+100 Elemente</button>
                        <button onclick="addRandomElements(1000)" class="demo-btn primary">+1000 Elemente</button>
                        <button onclick="resetHLL()" class="demo-btn danger">Reset</button>
                    </div>
                    <div class="hll-visualization">
                        <div class="hll-stats">
                            <div class="stat-box">
                                <span class="stat-label">Elemente adÄƒugate</span>
                                <span class="stat-value" id="hllTotalAdded">0</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label">Elemente unice (real)</span>
                                <span class="stat-value" id="hllActualUnique">0</span>
                            </div>
                            <div class="stat-box accent">
                                <span class="stat-label">Estimare HLL</span>
                                <span class="stat-value" id="hllEstimate">0</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label">Eroare</span>
                                <span class="stat-value" id="hllError">0%</span>
                            </div>
                        </div>
                        <div class="registers-container">
                            <h4>Registre HyperLogLog (16 registre)</h4>
                            <div class="registers-grid" id="hllRegisters">
                                <!-- Generated by JS -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Python Implementation -->
                <div class="code-section">
                    <h3>ğŸ“ Implementare Python</h3>
                    
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Python</span>
                            <button class="run-btn" onclick="runPythonCode('hllCode1')">
                                <span class="play-icon">â–¶</span> RuleazÄƒ
                            </button>
                        </div>
                        <pre><code id="hllCode1">import hashlib
import math

class HyperLogLog:
    def __init__(self, p=4):
        """
        IniÈ›ializeazÄƒ HyperLogLog.
        
        Args:
            p: NumÄƒrul de biÈ›i pentru index (2^p registre)
        """
        self.p = p
        self.m = 1 << p  # 2^p registre
        self.registers = [0] * self.m
        
        # ConstantÄƒ de corecÈ›ie pentru bias
        if self.m == 16:
            self.alpha = 0.673
        elif self.m == 32:
            self.alpha = 0.697
        elif self.m == 64:
            self.alpha = 0.709
        else:
            self.alpha = 0.7213 / (1 + 1.079 / self.m)
    
    def _hash(self, item):
        """GenereazÄƒ un hash pe 32 de biÈ›i."""
        h = hashlib.md5(str(item).encode()).hexdigest()
        return int(h[:8], 16)  # Primii 32 de biÈ›i
    
    def _count_leading_zeros(self, value, max_bits=32):
        """NumÄƒrÄƒ zerourile de la Ã®nceput (dupÄƒ biÈ›ii de index)."""
        if value == 0:
            return max_bits - self.p
        
        count = 0
        # Extragem biÈ›ii dupÄƒ cei p biÈ›i de index
        remaining_bits = max_bits - self.p
        mask = 1 << (remaining_bits - 1)
        
        while mask > 0 and (value & mask) == 0:
            count += 1
            mask >>= 1
        
        return count + 1  # +1 pentru poziÈ›ia primului bit de 1
    
    def add(self, item):
        """AdaugÄƒ un element Ã®n HLL."""
        h = self._hash(item)
        
        # Primii p biÈ›i = index registru
        index = h >> (32 - self.p)
        
        # Restul biÈ›ilor pentru leading zeros
        remaining = h & ((1 << (32 - self.p)) - 1)
        leading_zeros = self._count_leading_zeros(remaining, 32)
        
        # ActualizÄƒm registrul cu maximul
        self.registers[index] = max(self.registers[index], leading_zeros)
    
    def estimate(self):
        """EstimeazÄƒ cardinalitatea."""
        # Media armonicÄƒ
        Z = sum(2 ** (-r) for r in self.registers)
        E = self.alpha * self.m * self.m / Z
        
        # CorecÈ›ii pentru valori mici È™i mari
        if E <= 2.5 * self.m:
            # CorecÈ›ie pentru valori mici
            V = self.registers.count(0)
            if V > 0:
                E = self.m * math.log(self.m / V)
        
        return int(E)

# DemonstraÈ›ie
print("=" * 60)
print("HYPERLOGLOG - DemonstraÈ›ie")
print("=" * 60)

hll = HyperLogLog(p=4)  # 16 registre

# AdÄƒugÄƒm elemente (unele duplicate)
elemente = list(range(1000)) + list(range(500))  # 1000 unice, 500 duplicate
print(f"\nğŸ“¥ AdÄƒugÄƒm {len(elemente)} elemente ({1000} unice)...")

for elem in elemente:
    hll.add(elem)

print(f"\nğŸ“Š Registre HLL: {hll.registers}")
print(f"\nğŸ¯ Rezultate:")
print(f"   Elemente unice reale: 1000")
print(f"   Estimare HLL:         {hll.estimate()}")
print(f"   Eroare:               {abs(hll.estimate() - 1000) / 1000 * 100:.2f}%")

# Test cu mai multe elemente
print("\n" + "=" * 60)
print("Test scalabilitate")
print("=" * 60)

for n in [100, 1000, 10000, 50000]:
    hll = HyperLogLog(p=10)  # 1024 registre pentru precizie mai bunÄƒ
    for i in range(n):
        hll.add(f"element_{i}")
    
    estimate = hll.estimate()
    error = abs(estimate - n) / n * 100
    print(f"   n={n:6d}: estimat={estimate:6d}, eroare={error:.2f}%")</code></pre>
                        <div class="code-output" id="output-hllCode1">
                            <span class="output-placeholder">ApasÄƒ "RuleazÄƒ" pentru a vedea rezultatul...</span>
                        </div>
                    </div>
                </div>

                <!-- Math Section -->
                <div class="math-section">
                    <h3>ğŸ“ Analiza MatematicÄƒ</h3>
                    
                    <div class="formula-card">
                        <h4>Formula de Estimare</h4>
                        <div class="formula">
                            <div class="math-formula">
                                E = Î±<sub>m</sub> Ã— mÂ² Ã— (Î£ 2<sup>-M[j]</sup>)<sup>-1</sup>
                            </div>
                            <p>unde <code>M[j]</code> este valoarea registrului j È™i <code>Î±<sub>m</sub></code> este o constantÄƒ de corecÈ›ie.</p>
                        </div>
                    </div>

                    <div class="formula-card">
                        <h4>Eroarea Standard</h4>
                        <div class="formula">
                            <div class="math-formula">
                                Ïƒ â‰ˆ 1.04 / âˆšm
                            </div>
                            <p>Cu 1024 registre (1KB memorie), eroarea standard este ~3.25%</p>
                        </div>
                    </div>

                    <div class="formula-card">
                        <h4>Memorie NecesarÄƒ</h4>
                        <div class="formula">
                            <div class="math-formula">
                                Memorie = m Ã— 6 biÈ›i = 2<sup>p</sup> Ã— 6 biÈ›i
                            </div>
                            <p>Pentru p=14 (16384 registre): doar 12KB pentru miliarde de elemente!</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Python</span>
                            <button class="run-btn" onclick="runPythonCode('hllMath')">
                                <span class="play-icon">â–¶</span> RuleazÄƒ
                            </button>
                        </div>
                        <pre><code id="hllMath">import math

def calculeaza_eroare_standard(m):
    """CalculeazÄƒ eroarea standard pentru HLL."""
    return 1.04 / math.sqrt(m)

def memorie_necesara(p):
    """CalculeazÄƒ memoria necesarÄƒ Ã®n bytes."""
    m = 2 ** p
    # Fiecare registru are nevoie de 6 biÈ›i (pentru valori 0-63)
    return m * 6 / 8

print("=" * 60)
print("HYPERLOGLOG - Analiza Trade-off-ului Precizie vs Memorie")
print("=" * 60)

print("\nğŸ“Š Tabel Precizie vs Memorie:")
print("-" * 60)
print(f"{'p':^4} | {'Registre':^10} | {'Memorie':^12} | {'Eroare Std':^12}")
print("-" * 60)

for p in range(4, 18):
    m = 2 ** p
    mem = memorie_necesara(p)
    err = calculeaza_eroare_standard(m) * 100
    
    if mem < 1024:
        mem_str = f"{mem:.0f} B"
    else:
        mem_str = f"{mem/1024:.1f} KB"
    
    print(f"{p:^4} | {m:^10,} | {mem_str:^12} | {err:^10.2f}%")

print("-" * 60)

# ComparaÈ›ie practicÄƒ
print("\nğŸ“Š ComparaÈ›ie practicÄƒ pentru 1 miliard de elemente unice:")
print("-" * 60)

n = 1_000_000_000
print(f"Elemente de numÄƒrat: {n:,}")
print()

# HashSet
hashset_mem = n * 8 / 1024 / 1024 / 1024  # Presupunem 8 bytes/element
print(f"HashSet (exact):")
print(f"   Memorie: ~{hashset_mem:.1f} GB")
print(f"   Eroare:  0%")
print()

# HLL cu diferite configuraÈ›ii
for p in [10, 12, 14, 16]:
    m = 2 ** p
    mem = memorie_necesara(p)
    err = calculeaza_eroare_standard(m) * 100
    
    if mem < 1024:
        mem_str = f"{mem:.0f} B"
    else:
        mem_str = f"{mem/1024:.2f} KB"
    
    print(f"HyperLogLog (p={p}):")
    print(f"   Memorie: {mem_str}")
    print(f"   Eroare:  Â±{err:.2f}%")
    print(f"   Reducere memorie: {hashset_mem*1024*1024*1024/mem:,.0f}x")
    print()</code></pre>
                        <div class="code-output" id="output-hllMath">
                            <span class="output-placeholder">ApasÄƒ "RuleazÄƒ" pentru a vedea rezultatul...</span>
                        </div>
                    </div>
                </div>

                <!-- Applications -->
                <div class="applications-section">
                    <h3>ğŸŒ AplicaÈ›ii Ã®n Lumea RealÄƒ</h3>
                    <div class="app-grid">
                        <div class="app-card">
                            <div class="app-icon">ğŸ“Š</div>
                            <h4>Redis</h4>
                            <p>Comanda PFCOUNT foloseÈ™te HyperLogLog pentru a numÄƒra elemente unice cu doar 12KB.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸ”</div>
                            <h4>Google BigQuery</h4>
                            <p>FuncÈ›ia APPROX_COUNT_DISTINCT foloseÈ™te HLL pentru interogÄƒri rapide pe petabytes de date.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸ“ˆ</div>
                            <h4>Analytics</h4>
                            <p>NumÄƒrarea vizitatorilor unici, IP-uri distincte, sau evenimente unice Ã®n streaming.</p>
                        </div>
                        <div class="app-card">
                            <div class="app-icon">ğŸŒ</div>
                            <h4>ReÈ›ele</h4>
                            <p>Detectarea atacurilor DDoS prin monitorizarea numÄƒrului de IP-uri distincte.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conclusion -->
        <section class="section" id="conclusion">
            <div class="section-header">
                <span class="section-number">03</span>
                <h2>Concluzii</h2>
            </div>
            <div class="section-content">
                <div class="conclusion-grid">
                    <div class="conclusion-card bloom">
                        <h3>Bloom Filter</h3>
                        <div class="summary-points">
                            <p><strong>FoloseÈ™te cÃ¢nd:</strong></p>
                            <ul>
                                <li>Trebuie sÄƒ verifici apartenenÈ›a la o mulÈ›ime</li>
                                <li>PoÈ›i tolera false positives</li>
                                <li>Memoria este limitatÄƒ</li>
                            </ul>
                            <p><strong>Nu foloseÈ™te cÃ¢nd:</strong></p>
                            <ul>
                                <li>Ai nevoie sÄƒ È™tergi elemente</li>
                                <li>False positives sunt inacceptabile</li>
                            </ul>
                        </div>
                    </div>
                    <div class="conclusion-card hll">
                        <h3>HyperLogLog</h3>
                        <div class="summary-points">
                            <p><strong>FoloseÈ™te cÃ¢nd:</strong></p>
                            <ul>
                                <li>Trebuie sÄƒ numeri elemente distincte</li>
                                <li>Ai volume mari de date (Big Data)</li>
                                <li>PoÈ›i tolera o eroare de 1-3%</li>
                            </ul>
                            <p><strong>Nu foloseÈ™te cÃ¢nd:</strong></p>
                            <ul>
                                <li>Ai nevoie de numÄƒrare exactÄƒ</li>
                                <li>Trebuie sÄƒ È™tii care sunt elementele</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="final-comparison">
                    <h3>Tabel Comparativ Final</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>Bloom Filter</th>
                                <th>HyperLogLog</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Scop</td>
                                <td>Test de apartenenÈ›Äƒ</td>
                                <td>Estimare cardinalitate</td>
                            </tr>
                            <tr>
                                <td>OperaÈ›ie principalÄƒ</td>
                                <td>contains(x)</td>
                                <td>count_distinct()</td>
                            </tr>
                            <tr>
                                <td>Tip eroare</td>
                                <td>False positives</td>
                                <td>Eroare de estimare Â±%</td>
                            </tr>
                            <tr>
                                <td>Memorie tipicÄƒ</td>
                                <td>~10 biÈ›i/element</td>
                                <td>~12KB total</td>
                            </tr>
                            <tr>
                                <td>Complexitate timp</td>
                                <td>O(k)</td>
                                <td>O(1)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>
    </main>

    <!-- Slide Navigation -->
    <div class="slide-nav">
        <button class="slide-nav-btn prev" onclick="prevSlide()" title="Ãnapoi (â†)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M15 18l-6-6 6-6"/>
            </svg>
        </button>
        <div class="slide-progress">
            <span class="current-slide" id="currentSlide">1</span>
            <span class="slide-separator">/</span>
            <span class="total-slides" id="totalSlides">1</span>
        </div>
        <button class="slide-nav-btn next" onclick="nextSlide()" title="Ãnainte (â†’)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18l6-6-6-6"/>
            </svg>
        </button>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <!-- Slide Dots -->
    <div class="slide-dots" id="slideDots"></div>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="footer-content">
            <p>Structuri de Date È™i Algoritmi | Universitatea Politehnica BucureÈ™ti</p>
            <p class="footer-note">Material didactic pentru studenÈ›i</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>

